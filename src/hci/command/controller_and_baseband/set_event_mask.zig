const std = @import("std");

/// Reset the baseband
/// 
/// * OGF: `0x3`
/// * OCF: `0x1`
/// * Opcode: `0x10C`
/// 
/// Bluetooth Spec v5.2, Vol 4, Part E, section 7.3.1
/// 
/// The HCI_Set_Event_Mask command is used to control which events are generated by the HCI for the Host. If the bit in the Event_Mask is set to a one, then the event associated with that bit will be enabled. For an LE Controller, the “LE Meta event” bit in the event_Mask shall enable or disable all LE events in the LE Meta event (see Section 7.7.65). The event mask allows the Host to control how much it is interrupted.
/// 
/// The Controller shall ignore those bits which are reserved for future use or represent events which it does not support. If the Host sets any of these bits to 1, the Controller shall act as if they were set to 0.
/// 
/// ## Command Parameters
/// Accepts a list of event identifiers as atoms to indicate whether that
/// event should be included in the mask.
/// 
/// see Bluetooth Spec v5.2, Vol 4, Part E, section 7.3.1, Command parameters
/// 
/// ## Return Parameters
/// * `:status` - command status code
pub const SetEventMask = @This();

// Group Code
pub const OGF: u6  = 0x3;
// Command Code
pub const OCF: u10 = 0x1;
// Opcode
pub const OPC: u16 = 0x10C;

// fields:
const Events = packed union {
  fields: packed struct {
    padding: u15,
    le_met: u1,
    remote_host_supported_features_notification: u1,
    keypress_notification: u1,
    user_passkey_notification: u1,
    enhanced_flush_complete: u1,
    link_supervision_timeout_changed: u1,
    simple_pairing_complete: u1,
    remote_oob_data_request: u1,
    user_passkey_request: u1,
    user_confirmation_request: u1,
    io_capability_response: u1,
    io_capability_request: u1,
    encryption_key_refresh_complete: u1,
    extended_inquiry_result: u1,
    sniff_subrating: u1,
    synchronous_connection_changed: u1,
    synchronous_connection_complete: u1,
    read_remote_extended_features_complete: u1,
    inquiry_resultwith_rssi: u1,
    flow_specification_complete: u1,
    page_scan_repetition_mode_change: u1,
    page_scan_mode_change: u1,
    qos_violation: u1,
    connection_packet_type_changed: u1,
    read_clock_offset_complete: u1,
    max_slots_change: u1,
    data_buffer_overflow: u1,
    loopback_command: u1,
    link_key_notification: u1,
    link_key_request: u1,
    pin_code_request: u1,
    return_link_keys: u1,
    mode_change: u1,
    role_change: u1,
    flush_occurred: u1,
    hardware_error: u1,
    qos_setup_complete: u1,
    read_remote_version_information_complete: u1,
    read_remote_supported_features_complete: u1,
    master_link_key_complete: u1,
    change_connection_link_key_complete: u1,
    encryption_change: u1,
    remote_name_request_complete: u1,
    authentication_complete: u1,
    disconnection_complete: u1,
    connection_request: u1,
    connection_complete: u1,
    inquiry_result: u1,
    inquiry_complete: u1,
  },
  data: u64,
};

events: Events,
// payload length
length: usize,
pub fn init() SetEventMask {
  return .{
    .length = 11,
    .events = .{.data = @as(u64, 0xffff_ffff_fff1_0000)}
  };
}

// encode from a struct
pub fn encode(self: SetEventMask, allocator: std.mem.Allocator) ![]u8 {
  var command = try allocator.alloc(u8, self.length);
  errdefer allocator.free(command);
  command[0] = OCF;
  command[1] = OGF << 2;
  command[2] = 8;
  std.mem.writeInt(u64, command[3..11], self.events.data, .Big);

  // TODO: implement encoding SetEventMask

  return command;
}

test "SetEventMask encode" {
  const set_event_mask = SetEventMask.init();
  const encoded = try SetEventMask.encode(set_event_mask, std.testing.allocator);
  defer std.testing.allocator.free(encoded);
  try std.testing.expect(encoded[0] == OCF);
  try std.testing.expect(encoded[1] == OGF << 2);
}
